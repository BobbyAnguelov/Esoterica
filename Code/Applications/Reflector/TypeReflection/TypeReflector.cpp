#include "TypeReflector.h"
#include "Clang/ClangParser.h"
#include "ReflectionDatabase.h"
#include "CodeGenerator.h"

#include "Base/FileSystem/FileSystemUtils.h"
#include "Base/Time/Timers.h"
#include "Base/Utils/TopologicalSort.h"

#include <eastl/sort.h>
#include <fstream>
#include <iostream>
#include <filesystem>

//-------------------------------------------------------------------------

namespace EE::TypeSystem::Reflection
{
    TypeInfoReflector::TypeInfoReflector( FileSystem::Path const& slnPath )
        : m_solution( slnPath )
    {
    }

    bool TypeInfoReflector::ParseSolution()
    {
        return m_solution.Parse();
    }

    bool TypeInfoReflector::Clean()
    {
        TVector<FileSystem::Path> generatedFiles;

        auto CreateEmptyFile = [this] ( FileSystem::Path const& filePath )
        {
            std::fstream outputFile( filePath.c_str(), std::ios::out | std::ios::trunc );
            if ( !outputFile.is_open() )
            {
                return Utils::PrintError( " * Error creating module file: %s", filePath.c_str() );
            }
            outputFile.close();

            return true;
        };

        //-------------------------------------------------------------------------

        std::cout << " * Cleaning Solution: " << m_solution.m_path.c_str() << std::endl;
        std::cout << " ----------------------------------------------" << std::endl << std::endl;

        // Delete all auto-generated directories for valid projects
        for ( ReflectedProject& prj : m_solution.m_projects )
        {
            std::cout << " * Cleaning Project - " << prj.m_name.c_str() << std::endl;

            FileSystem::Path const autoGeneratedDirectory = prj.m_typeInfoDirectoryPath;
            if ( !FileSystem::EraseDir( autoGeneratedDirectory ) )
            {
                return Utils::PrintError( " * Error erasing directory: %s", autoGeneratedDirectory.c_str() );
            }

            // Create autogen dir
            if ( !FileSystem::CreateDir( autoGeneratedDirectory ) )
            {
                return Utils::PrintError( " * Error erasing directory: %s", autoGeneratedDirectory.c_str() );
            }

            // Clean all generated files
            prj.GetTypeInfoFilePaths( generatedFiles );
            for ( auto const& generatedFilePath : generatedFiles )
            {
                if ( !CreateEmptyFile( generatedFilePath ) )
                {
                    return false;
                }
            }
        }

        std::cout << std::endl;

        // Delete all auto-generated directories for excluded projects (just to be safe)
        for ( FileSystem::Path& prjPath : m_solution.m_excludedProjectPaths )
        {
            FileSystem::Path const autoGeneratedDirectory = ReflectedProject::GetProjectTypeInfoPath( prjPath.GetParentDirectory() );
            std::cout << " * Cleaning Excluded Project - " << autoGeneratedDirectory.c_str() << std::endl;

            if ( !FileSystem::EraseDir( autoGeneratedDirectory ) )
            {
                return Utils::PrintError( " * Error erasing directory: %s", autoGeneratedDirectory.c_str() );
            }
        }

        std::cout << std::endl;

        FileSystem::Path engineTypeRegistrationFilePath = m_solution.GetRuntimeTypeRegistrationPath();
        if ( FileSystem::EraseFile( engineTypeRegistrationFilePath ) )
        {
            std::cout << " * Cleaning Engine Type Registration - " << engineTypeRegistrationFilePath.c_str() << std::endl;
        }
        else
        {
            return Utils::PrintError( " * Error erasing file: %s", engineTypeRegistrationFilePath.c_str() );
        }

        FileSystem::Path editorTypeRegistrationFilePath = m_solution.GetToolsTypeRegistrationPath();
        if ( FileSystem::EraseFile( editorTypeRegistrationFilePath ) )
        {
            std::cout << " * Cleaning Editor Type Registration - " << editorTypeRegistrationFilePath.c_str() << std::endl;
        }
        else
        {
            return Utils::PrintError( " * Error erasing file: %s", editorTypeRegistrationFilePath.c_str() );
        }

        //-------------------------------------------------------------------------

        std::cout << std::endl;
        std::cout << " >>> Cleaning - Complete!" << std::endl << std::endl;
        return true;
    }

    bool TypeInfoReflector::Build()
    {
        ReflectionDatabase database( m_solution.m_projects );

        std::cout << " * Reflecting Solution: " << m_solution.m_path.c_str() << std::endl;
        std::cout << " ----------------------------------------------" << std::endl << std::endl;

        Milliseconds time = 0;
        {
            ScopedTimer<PlatformClock> timer( time );

            //-------------------------------------------------------------------------

            // Create list of all headers to parse
            TVector<ReflectedHeader*> headersToParse;
            for ( ReflectedProject& prj : m_solution.m_projects )
            {
                // Ignore projects with no module header
                if ( !prj.m_moduleHeaderID.IsValid() )
                {
                    continue;
                }

                // Add all dirty headers to the list of file to be parsed
                bool moduleHeaderAdded = false;
                for ( ReflectedHeader& headerInfo : prj.m_headerFiles )
                {
                    headersToParse.push_back( &headerInfo );
                }
            }

            //-------------------------------------------------------------------------

            if ( !headersToParse.empty() )
            {
                std::cout << " * Reflecting C++ Code - First Pass (With Dev Tools) - ";

                // Parse headers
                ClangParser clangParser( m_solution.m_parentDirectoryPath, &database );
                if ( !clangParser.Parse( headersToParse, ClangParser::DevToolsPass ) )
                {
                    std::cout << "\n ! Error: " << clangParser.GetErrorMessage().c_str() << std::endl;
                    return false;
                }
                Milliseconds clangParsingTime = clangParser.GetParsingTime();
                Milliseconds clangVisitingTime = clangParser.GetVisitingTime();
                std::cout << "Complete! ( P:" << (float) clangParsingTime << "ms, V:" << (float) clangVisitingTime << "ms )" << std::endl;

                std::cout << " * Reflecting C++ Code - Second Pass (No Dev Tools) - ";

                // Second parse to detect dev-only types
                if ( !clangParser.Parse( headersToParse, ClangParser::NoDevToolsPass ) )
                {
                    std::cout << "\n ! Error: " << clangParser.GetErrorMessage().c_str() << std::endl;
                    return false;
                }
                clangParsingTime = clangParser.GetParsingTime();
                clangVisitingTime = clangParser.GetVisitingTime();
                std::cout << "Complete! ( P:" << (float) clangParsingTime << "ms, V:" << (float) clangVisitingTime << "ms )" << std::endl;

                // Finalize database data
                if ( !database.ValidateDataFileRegistrations() )
                {
                    std::cout << "\n ! Database Validation Error: " << database.GetErrorMessage() << std::endl;
                    return false;
                }

                if ( !database.ProcessAndValidateReflectedProperties() )
                {
                    std::cout << "\n ! Database Validation Error: " << database.GetErrorMessage() << std::endl;
                    return false;
                }

                if ( database.HasWarnings() )
                {
                    std::cout << "\n ! Database Validation Warnings: \n" << database.GetWarningMessage() << std::endl;
                }

                database.CleanupResourceHierarchy();
            }

            //-------------------------------------------------------------------------

            std::cout << " * Generating Code - ";
            Milliseconds codeGenTime = 0;

            CodeGenerator generator( m_solution.m_parentDirectoryPath, database );
            {
                ScopedTimer<PlatformClock> codeGenTimer( codeGenTime );
                if ( !generator.GenerateCodeForSolution() )
                {
                    return Utils::PrintError( generator.GetErrorMessage() );
                }
            }

            if ( !WriteGeneratedFiles( generator ) )
            {
                std::cout << "\n ! Error: Failed to write generated files! Attempting to clean all autogenerated folders!" << std::endl;
                Clean();
                return false;
            }

            std::cout << "Complete! ( " << (float) codeGenTime << "ms )" << std::endl;

            //-------------------------------------------------------------------------

            if ( generator.HasWarnings() )
            {
                Utils::PrintWarning( generator.GetWarningMessage() );
            }
        }

        std::cout << std::endl;
        std::cout << " >>> Reflection - Complete! ( " << (float) time.ToSeconds() << "s )" << std::endl;

        return true;
    }

    bool TypeInfoReflector::WriteGeneratedFiles( class CodeGenerator const& generator )
    {
        EE_ASSERT( !generator.HasErrors() );
        TVector<CodeGenerator::GeneratedFile> const& generatedFiles = generator.GetGeneratedFiles();

        // Delete all auto-generated directories for excluded projects (just to be safe)
        //-------------------------------------------------------------------------

        for ( auto& prjPath : m_solution.m_excludedProjectPaths )
        {
            FileSystem::Path const autoGeneratedDirectory = ReflectedProject::GetProjectTypeInfoPath( prjPath.GetParentDirectory() );
            if ( autoGeneratedDirectory.Exists() && !FileSystem::EraseDir( autoGeneratedDirectory ) )
            {
                return Utils::PrintError( " * Error erasing directory: %s", autoGeneratedDirectory.c_str() );
            }
        }

        // Get list of files in all known auto-generated directories
        //-------------------------------------------------------------------------

        TVector<FileSystem::Path> existingFilesOnDisk;
        TVector<FileSystem::Path> directoryContents;

        for ( ReflectedProject& prj : m_solution.m_projects )
        {
            FileSystem::Path const autoGeneratedTypeInfoDirectory = prj.m_typeInfoDirectoryPath;
            autoGeneratedTypeInfoDirectory.EnsureDirectoryExists();
            FileSystem::GetDirectoryContents( autoGeneratedTypeInfoDirectory, directoryContents );

            for ( auto const& path : directoryContents )
            {
                // There should be no directories inside the auto-generated folders
                if( path.IsDirectoryPath() )
                { 
                    if ( !FileSystem::EraseDir( path ) )
                    {
                        return Utils::PrintError( " * Error erasing directory: %s", path.c_str() );
                    }
                }
                else // Push discovered path
                {
                    existingFilesOnDisk.emplace_back( path );
                }
            }
        }

        // Add runtime and tools registration headers
        VectorEmplaceBackUnique( existingFilesOnDisk, m_solution.GetRuntimeTypeRegistrationPath() );
        VectorEmplaceBackUnique( existingFilesOnDisk, m_solution.GetToolsTypeRegistrationPath() );

        // Compare list of existing files with expected files and delete any files that shouldn't exist
        //-------------------------------------------------------------------------

        for ( FileSystem::Path const& existingFile : existingFilesOnDisk )
        {
            if ( !VectorContains( generatedFiles, existingFile, [] ( CodeGenerator::GeneratedFile const& lhs, FileSystem::Path const& rhs ) { return lhs.m_path == rhs; } ) )
            {
                if ( !FileSystem::EraseFile( existingFile ) )
                {
                    return Utils::PrintError( " * Error erasing file: %s", existingFile.c_str() );
                }
            }
        }

        // Write out any files that have actually changed
        //-------------------------------------------------------------------------

        for ( CodeGenerator::GeneratedFile const& generatedFile : generatedFiles )
        {
            if ( !FileSystem::UpdateTextFile( generatedFile.m_path, generatedFile.m_contents ) )
            {
                return Utils::PrintError( " * Error creating generated file: %s", generatedFile.m_path.c_str() );
            }
        }

        // Bump the solution file to force a solution reload (to refresh all automatically detected and compiled files)
        return m_solution.DirtyAllProjectFiles();
    }
}