#pragma once
#include "ReflectedHeader.h"
#include "ReflectionSettings.h"

//-------------------------------------------------------------------------

namespace EE::TypeSystem::Reflection
{
    class ReflectedProject
    {
    public:

        enum class ParseResult
        {
            ErrorOccured,
            IgnoreProjectNoModule,
            IgnoreProjectModuleNotRegistered,
            IgnoreProjectModuleNoHeaders,
            ValidProject,
        };

        //-------------------------------------------------------------------------

        inline static StringID GetProjectID( FileSystem::Path const& projectFilePath )
        {
            String lowercasePath = projectFilePath.GetString();
            lowercasePath.make_lower();
            return StringID( lowercasePath.c_str() );
        }

        inline static FileSystem::Path GetProjectTypeInfoPath( FileSystem::Path const& projectDirectoryPath )
        {
            FileSystem::Path typeInfoDirectoryPath = projectDirectoryPath;
            typeInfoDirectoryPath.Append( Settings::g_moduleDirectoryName, true );
            typeInfoDirectoryPath.Append( Settings::g_autogeneratedDirectoryName, true );
            typeInfoDirectoryPath.Append( Settings::g_autogeneratedTypeInfoDirectoryName, true );
            return typeInfoDirectoryPath;
        }

    public:

        ReflectedProject( FileSystem::Path const& path );

        ParseResult Parse();

        inline bool IsBaseModule() const { return m_isBaseProject; }

        inline ReflectedHeader const* GetModuleHeader() const
        {
            EE_ASSERT( m_moduleHeaderID.IsValid() );
            for ( auto const& header : m_headerFiles )
            {
                if ( header.m_ID == m_moduleHeaderID )
                {
                    return &header;
                }
            }

            EE_UNREACHABLE_CODE();
            return nullptr;
        }

        // Get the module's type-info registration header file path
        inline FileSystem::Path const GetTypeInfoHeaderFilePath() const
        {
            FileSystem::Path const directoryPath = m_typeInfoDirectoryPath;
            ReflectedHeader const* pModuleHeader = GetModuleHeader();
            InlineString const filenameStr( InlineString::CtorSprintf(), "%s.%s.%s", pModuleHeader->m_path.GetFilenameWithoutExtension().c_str(), Settings::g_typeinfoFileSuffix, "h" );
            return directoryPath.GetAppended( filenameStr.c_str() );
        }

        // Get the module's type-info registration source file path
        inline FileSystem::Path const GetTypeInfoSourceFilePath() const
        {
            FileSystem::Path const directoryPath = m_typeInfoDirectoryPath;
            ReflectedHeader const* pModuleHeader = GetModuleHeader();
            InlineString const filenameStr( InlineString::CtorSprintf(), "%s.%s.%s", pModuleHeader->m_path.GetFilenameWithoutExtension().c_str(), Settings::g_typeinfoFileSuffix, "cpp" );
            return directoryPath.GetAppended( filenameStr.c_str() );
        }

        // Get the paths to the module's type-info registration files
        inline void GetTypeInfoFilePaths( TVector<FileSystem::Path>& outFiles ) const
        {
            outFiles.emplace_back( GetTypeInfoHeaderFilePath() );
            outFiles.emplace_back( GetTypeInfoSourceFilePath() );
        }

    public:

        StringID                                        m_ID;
        String                                          m_name;
        FileSystem::Path                                m_path;
        FileSystem::Path                                m_parentDirectoryPath;
        FileSystem::Path                                m_typeInfoDirectoryPath;
        String                                          m_exportMacro;
        StringID                                        m_moduleHeaderID;
        uint32_t                                        m_dependencyCount = 0;
        TVector<ReflectedHeader>                        m_headerFiles;
        TVector<StringID>                               m_dependencies;
        mutable String                                  m_moduleClassName;
        bool                                            m_includeInAutogenerateModuleRegistrationList = true;
        bool                                            m_isBaseProject = false;
        bool                                            m_isToolsProject = false;
    };
}