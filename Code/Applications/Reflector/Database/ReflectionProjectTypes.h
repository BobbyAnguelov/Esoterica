#pragma once

#include "Applications/Reflector/ReflectorSettingsAndUtils.h"
#include "Base/Types/StringID.h"
#include "Base/FileSystem/FileSystemPath.h"

//-------------------------------------------------------------------------

namespace EE::TypeSystem::Reflection
{
    typedef StringID HeaderID;
    typedef StringID ProjectID;

    //-------------------------------------------------------------------------

    struct HeaderInfo
    {
        inline static HeaderID GetHeaderID( FileSystem::Path const& headerFilePath )
        {
            String lowercasePath = headerFilePath;
            lowercasePath.make_lower();
            return StringID( lowercasePath.c_str() );
        }

    public:

        inline bool IsInToolsLayer() const
        {
            return Utils::IsFileUnderToolsProject( m_filePath );
        }

        inline FileSystem::Path GetAutogeneratedTypeInfoFileName( FileSystem::Path const& directoryPath ) const
        {
            EE_ASSERT( directoryPath.IsDirectoryPath() );
            String outPath = GetAutogeneratedFileName( directoryPath.GetString() );
            outPath.append( ".cpp" );
            return outPath;
        }

    private:

        inline String GetAutogeneratedFileName( String const& directoryPathStr ) const
        {
            EE_ASSERT( !directoryPathStr.empty() );
            return String( String::CtorSprintf(), "%s_AutoGenerated_%s", directoryPathStr.c_str(), m_filePath.GetFileNameWithoutExtension().c_str() );
        }

    public:

        HeaderID                        m_ID;
        ProjectID                       m_projectID;
        FileSystem::Path                m_filePath;
        uint64_t                        m_timestamp = 0;
        uint64_t                        m_checksum = 0;
        TVector<String>                 m_fileContents;
    };

    //-------------------------------------------------------------------------

    struct ProjectInfo
    {
        inline static ProjectID GetProjectID( FileSystem::Path const& projectFilePath )
        {
            String lowercasePath = projectFilePath;
            lowercasePath.make_lower();
            return StringID( lowercasePath.c_str() );
        }

        inline HeaderInfo const& GetModuleHeaderDesc() const
        {
            EE_ASSERT( m_moduleHeaderID.IsValid() );
            for ( auto const& headerInfo : m_headerFiles )
            {
                if ( headerInfo.m_ID == m_moduleHeaderID )
                {
                    return headerInfo;
                }
            }

            EE_UNREACHABLE_CODE();
            static HeaderInfo const temp;
            return temp;
        }

    public:

        ProjectID                       m_ID;
        String                          m_name;
        FileSystem::Path                m_path;
        String                          m_exportMacro;
        HeaderID                        m_moduleHeaderID;
        uint32_t                        m_dependencyCount = 0;
        TVector<HeaderInfo>             m_headerFiles;
        TVector<uint32_t>               m_dirtyHeaders;
        TVector<ProjectID>              m_dependencies;
        mutable String                  m_moduleClassName;
        bool                            m_includeInAutogenerateModuleRegistrationList = true;
        bool                            m_isToolsModule = false;
    };

    //-------------------------------------------------------------------------

    struct SolutionInfo
    {
        FileSystem::Path                m_path;
        TVector<ProjectInfo>            m_projects;
        TVector<FileSystem::Path>       m_excludedProjects;
    };
}