#pragma once

#include "Base/TypeSystem/TypeInfo.h"
#include "Base/TypeSystem/CoreTypeIDs.h"
#include "Base/Resource/ResourceTypeID.h"
#include "Base/FileSystem/FileSystemPath.h"
#include "Applications/Reflector/ReflectorSettingsAndUtils.h"

//-------------------------------------------------------------------------

namespace EE::TypeSystem::Reflection
{
    struct HeaderInfo
    {
        inline static StringID GetHeaderID( FileSystem::Path const& headerFilePath )
        {
            String lowercasePath = headerFilePath.GetString();
            lowercasePath.make_lower();
            return StringID( lowercasePath.c_str() );
        }

    public:

        inline bool IsInToolsLayer() const
        {
            return Utils::IsFileUnderToolsProject( m_filePath );
        }

        inline FileSystem::Path const GetTypeInfoFilePath( FileSystem::Path const& projectDirectoryPath ) const
        {
            return Utils::GetAutogeneratedFilePath( projectDirectoryPath, m_filePath.GetFilenameWithoutExtension().c_str(), Settings::g_typeinfoFileSuffix, "cpp" );
        }

    public:

        StringID                        m_ID;
        StringID                        m_projectID;
        FileSystem::Path                m_filePath;
        uint64_t                        m_timestamp = 0;
        uint64_t                        m_checksum = 0;
        TVector<String>                 m_fileContents;
    };

    //-------------------------------------------------------------------------

    struct ProjectInfo
    {

    public:

        inline static StringID GetProjectID( FileSystem::Path const& projectFilePath )
        {
            String lowercasePath = projectFilePath.GetString();
            lowercasePath.make_lower();
            return StringID( lowercasePath.c_str() );
        }

        inline bool IsBaseModule() const
        {
            return m_name == Settings::g_allowedProjectNames[0].m_pFullName;
        }

        inline HeaderInfo const& GetModuleHeaderInfo() const
        {
            EE_ASSERT( m_moduleHeaderID.IsValid() );
            for ( auto const& headerInfo : m_headerFiles )
            {
                if ( headerInfo.m_ID == m_moduleHeaderID )
                {
                    return headerInfo;
                }
            }

            EE_UNREACHABLE_CODE();
            static HeaderInfo const temp;
            return temp;
        }

        inline FileSystem::Path const GetAutogeneratedDirectoryPath() const
        {
            return Utils::GetAutogeneratedDirectoryNameForProject( m_path );
        }

        inline FileSystem::Path const GetTypeInfoHeaderFilePath() const
        {
            FileSystem::Path const directoryPath = GetAutogeneratedDirectoryPath();
            HeaderInfo const& moduleHeaderInfo = GetModuleHeaderInfo();
            return Utils::GetAutogeneratedFilePath( directoryPath, moduleHeaderInfo.m_filePath.GetFilenameWithoutExtension().c_str(), Settings::g_typeinfoFileSuffix, "h" );
        }

        inline FileSystem::Path const GetTypeInfoSourceFilePath() const
        {
            FileSystem::Path const directoryPath = GetAutogeneratedDirectoryPath();
            HeaderInfo const& moduleHeaderInfo = GetModuleHeaderInfo();
            return Utils::GetAutogeneratedFilePath( directoryPath, moduleHeaderInfo.m_filePath.GetFilenameWithoutExtension().c_str(), Settings::g_typeinfoFileSuffix, "cpp" );
        }

        inline void GetAllGeneratedFiles( TVector<FileSystem::Path>& outFiles )
        {
            outFiles.emplace_back( GetTypeInfoHeaderFilePath() );
            outFiles.emplace_back( GetTypeInfoSourceFilePath() );
        }

    public:

        StringID                        m_ID;
        String                          m_name;
        String                          m_shortName;
        FileSystem::Path                m_path;
        String                          m_exportMacro;
        StringID                        m_moduleHeaderID;
        uint32_t                        m_dependencyCount = 0;
        TVector<HeaderInfo>             m_headerFiles;
        TVector<StringID>               m_dependencies;
        mutable String                  m_moduleClassName;
        bool                            m_includeInAutogenerateModuleRegistrationList = true;
        bool                            m_isToolsModule = false;
    };

    //-------------------------------------------------------------------------

    struct ReflectedProperty
    {

    public:

        ReflectedProperty() = default;

        ReflectedProperty( String const& name, int32_t lineNumber )
            : m_propertyID( name )
            , m_name( name )
            , m_lineNumber( lineNumber )
        {}

        ReflectedProperty( String const& name, String const& typeName, int32_t lineNumber )
            : m_propertyID( name )
            , m_name( name )
            , m_typeName( typeName )
            , m_lineNumber( lineNumber )
        {}

        inline bool IsStructureProperty() const { return m_flags.IsFlagSet( PropertyInfo::Flags::IsStructure ); }
        inline bool IsEnumProperty() const { return m_flags.IsFlagSet( PropertyInfo::Flags::IsEnum ); }
        inline bool IsBitFlagsProperty() const { return m_flags.IsFlagSet( PropertyInfo::Flags::IsBitFlags ); }
        inline bool IsTypeInstanceProperty() const { return m_flags.IsFlagSet( PropertyInfo::Flags::IsTypeInstance ); }
        inline bool IsArrayProperty() const { return m_flags.IsFlagSet( PropertyInfo::Flags::IsArray ) || m_flags.IsFlagSet( PropertyInfo::Flags::IsDynamicArray ); }
        inline bool IsStaticArrayProperty() const { return m_flags.IsFlagSet( PropertyInfo::Flags::IsArray ) && !m_flags.IsFlagSet( PropertyInfo::Flags::IsDynamicArray ); }
        inline bool IsDynamicArrayProperty() const { return m_flags.IsFlagSet( PropertyInfo::Flags::IsDynamicArray ); }
        inline bool IsResourcePtrProperty() const { return m_flags.IsFlagSet( PropertyInfo::Flags::IsResourcePtr ); }
        inline uint32_t GetArraySize() const { EE_ASSERT( m_arraySize > 0 ); return (uint32_t) m_arraySize; }

        inline bool operator==( ReflectedProperty const& RHS ) const { return m_propertyID == RHS.m_propertyID; }
        inline bool operator!=( ReflectedProperty const& RHS ) const { return m_propertyID != RHS.m_propertyID; }

        // MetaData
        //-------------------------------------------------------------------------

        void GenerateMetaData( InlineString& outWarnings );

    public:

        StringID                                        m_propertyID;
        int32_t                                         m_lineNumber = -1;
        TypeID                                          m_typeID;
        String                                          m_name;
        String                                          m_rawMetaDataStr;
        PropertyMetadata                                m_metaData;
        String                                          m_reflectedFriendlyName; // the generated friendly name from the c++ name
        String                                          m_reflectedDescription;
        String                                          m_typeName;
        String                                          m_templateArgTypeName;
        int32_t                                         m_arraySize = -1;
        TBitFlags<PropertyInfo::Flags>                  m_flags;
        bool                                            m_isDevOnly = true;
    };

    //-------------------------------------------------------------------------

    struct ReflectedEnumConstant
    {
        StringID                                        m_ID;
        String                                          m_label;
        int32_t                                         m_value;
        String                                          m_description;
    };

    struct ReflectedType
    {
        enum class Flags
        {
            IsAbstract = 0,
            IsEnum,
            IsEntity,
            IsEntityComponent,
            IsEntitySystem,
            IsEntityWorldSystem
        };

    public:

        ReflectedType() = default;

        ReflectedType( TypeID ID, String const& name )
            : m_ID( ID )
            , m_name( name )
        {}

        inline bool IsAbstract() const { return m_flags.IsFlagSet( Flags::IsAbstract ); }
        inline bool IsEnum() const { return m_flags.IsFlagSet( Flags::IsEnum ); }
        inline bool IsEntity() const { return m_flags.IsFlagSet( Flags::IsEntity ); }
        inline bool IsEntityComponent() const { return m_flags.IsFlagSet( Flags::IsEntityComponent ); }
        inline bool IsEntitySystem() const { return m_flags.IsFlagSet( Flags::IsEntitySystem ); }
        inline bool IsEntityWorldSystem() const { return m_flags.IsFlagSet( Flags::IsEntityWorldSystem ); }

        // Structure functions
        ReflectedProperty const* GetPropertyDescriptor( StringID propertyID ) const;

        // Enum functions
        void AddEnumConstant( ReflectedEnumConstant const& constant );
        bool IsValidEnumLabelID( StringID labelID ) const;
        bool GetValueFromEnumLabel( StringID labelID, uint32_t& value ) const;

        // Dev tools helpers
        String GetFriendlyName() const;
        String GetInternalNamespace() const;
        String GetCategory() const;

        // Generate additional type info
        inline bool HasProperties() const { return !m_properties.empty(); }
        bool HasArrayProperties() const;
        bool HasDynamicArrayProperties() const;
        bool HasResourcePtrProperties() const;
        bool HasResourcePtrOrStructProperties() const;

    public:

        TypeID                                          m_ID;
        StringID                                        m_headerID;
        String                                          m_name = "Invalid";
        String                                          m_namespace;
        TBitFlags<Flags>                                m_flags;

        // Structures
        TypeID                                          m_parentID;
        TVector<ReflectedProperty>                      m_properties;

        // Enums
        CoreTypeID                                      m_underlyingType = CoreTypeID::Uint8;
        TVector<ReflectedEnumConstant>                  m_enumConstants;

        bool                                            m_isDevOnly = true;
    };

    //-------------------------------------------------------------------------

    struct ReflectedResourceType
    {
        // Fill the resource type ID and the friendly name from the macro registration string
        bool TryParseResourceRegistrationMacroString( String const& registrationStr );

    public:

        TypeID                                          m_typeID;
        ResourceTypeID                                  m_resourceTypeID;
        String                                          m_friendlyName;
        StringID                                        m_headerID;
        String                                          m_className;
        String                                          m_namespace;
        TVector<TypeID>                                 m_parents;
        bool                                            m_isDevOnly = true;
    };

    //-------------------------------------------------------------------------

    struct ReflectedDataFileType
    {
        // Fill the data type ID and the friendly name from the macro registration string
        bool TryParseDataFileRegistrationMacroString( String const& registrationStr );

    public:

        TypeID                                          m_typeID;
        uint32_t                                        m_extensionFourCC = 0;
        String                                          m_friendlyName;
        StringID                                        m_headerID;
        String                                          m_className;
        String                                          m_namespace;
        bool                                            m_isDevOnly = true;
    };
}