#include "ResourceServer.h"
#include "ResourceCompileDependencyTree.h"
#include "_AutoGenerated/ToolsTypeRegistration.h"
#include "EngineTools/Resource/ResourceCompiler.h"
#include "EngineTools/ThirdParty/subprocess/subprocess.h"
#include "Engine/Entity/EntityDescriptors.h"
#include "Engine/Entity/EntitySerialization.h"
#include "System/Resource/ResourceProviders/ResourceNetworkMessages.h"
#include "System/IniFile.h"
#include "System/FileSystem/FileSystem.h"
#include "System/FileSystem/FileSystemUtils.h"

//-------------------------------------------------------------------------

namespace EE::Resource
{
    class CompilationTask final : public ITaskSet
    {

    public:

        CompilationTask( ResourceServerContext const& context, Threading::LockFreeQueue<CompilationTask*>& completedTaskQueue, CompilationRequest* pRequest )
            : ITaskSet( 1 )
            , m_context( context )
            , m_completedTaskQueue( completedTaskQueue )
            , m_pRequest( pRequest )
        {
            EE_ASSERT( m_context.IsValid() );

            // No default ctor for subprocess struct, so zero-init
            Memory::MemsetZero( &m_subProcess );
        }

        ~CompilationTask()
        {
            EE_ASSERT( !subprocess_alive( &m_subProcess ) );
        }

        inline CompilationRequest* GetRequest() const { return m_pRequest; }

    private:

        virtual void ExecuteRange( TaskSetPartition range, uint32_t threadnum ) override final
        {
            // If we are not exiting the application and the request needs to be processed
            // Note: we enqueue failed requests as well just to have a uniform code flow
            if ( !m_context.m_isExiting && !m_pRequest->IsComplete() )
            {
                if ( !IsUpToDate() )
                {
                    Compile();
                }
            }

            //-------------------------------------------------------------------------

            m_completedTaskQueue.enqueue( this );
        }

        bool IsUpToDate()
        {
            EE_ASSERT( m_pRequest != nullptr );

            //-------------------------------------------------------------------------

            // Check compiler
            ResourceTypeID const resourceTypeID = m_pRequest->m_resourceID.GetResourceTypeID();
            auto pCompiler = m_context.m_pCompilerRegistry->GetCompilerForResourceType( resourceTypeID );
            if ( pCompiler == nullptr )
            {
                m_pRequest->m_log.sprintf( "Error: No compiler found for resource type (%s)!", m_pRequest->m_resourceID.ToString().c_str() );
                m_pRequest->m_status = CompilationRequest::Status::Failed;
            }

            // File Validity check
            bool sourceFileExists = false;
            if ( m_pRequest->m_status != CompilationRequest::Status::Failed )
            {
                sourceFileExists = FileSystem::Exists( m_pRequest->m_sourceFile );
                if ( pCompiler->IsInputFileRequired() && !sourceFileExists )
                {
                    m_pRequest->m_log.sprintf( "Error: Source file (%s) doesnt exist!", m_pRequest->m_sourceFile.GetFullPath().c_str() );
                    m_pRequest->m_status = CompilationRequest::Status::Failed;
                }
            }

            // Try create target dir
            if ( m_pRequest->m_status != CompilationRequest::Status::Failed )
            {
                if ( !m_pRequest->m_destinationFile.EnsureDirectoryExists() )
                {
                    m_pRequest->m_log.sprintf( "Error: Destination path (%s) doesnt exist!", m_pRequest->m_destinationFile.GetParentDirectory().c_str() );
                    m_pRequest->m_status = CompilationRequest::Status::Failed;
                }
            }

            // Check that target file isnt read-only
            if ( m_pRequest->m_status != CompilationRequest::Status::Failed )
            {
                if ( FileSystem::Exists( m_pRequest->m_destinationFile ) && FileSystem::IsFileReadOnly( m_pRequest->m_destinationFile ) )
                {
                    m_pRequest->m_log.sprintf( "Error: Destination file (%s) is read-only!", m_pRequest->m_destinationFile.GetFullPath().c_str() );
                    m_pRequest->m_status = CompilationRequest::Status::Failed;
                }
            }

            // Check compile dependency and if this resource needs compilation
            m_pRequest->m_upToDateCheckTimeStarted = PlatformClock::GetTime();
            CompileDependencyTree compileDependencyTree( m_context );
            if ( compileDependencyTree.BuildTree( m_pRequest->m_resourceID ) )
            {
                CompileDependencyNode const* pRoot = compileDependencyTree.GetRoot();
                m_pRequest->m_compilerVersion = pRoot->m_compilerVersion;
                m_pRequest->m_fileTimestamp = pRoot->m_timestamp;
                m_pRequest->m_sourceTimestampHash = pRoot->m_combinedHash;
                m_pRequest->m_status = pRoot->IsUpToDate() ? CompilationRequest::Status::SucceededUpToDate : CompilationRequest::Status::Pending;
            }
            else // Failed to generate dependency tree
            {
                m_pRequest->m_log.sprintf( compileDependencyTree.GetErrorMessage().c_str() );
                m_pRequest->m_status = CompilationRequest::Status::Failed;
            }
            m_pRequest->m_upToDateCheckTimeFinished = PlatformClock::GetTime();

            // Force compilation
            if ( m_pRequest->HasSucceeded() && m_pRequest->RequiresForcedRecompiliation() )
            {
                m_pRequest->m_status = CompilationRequest::Status::Pending;
            }

            //-------------------------------------------------------------------------

            return m_pRequest->IsComplete();
        }

        void Compile()
        {
            EE_ASSERT( !m_pRequest->m_compilerArgs.empty() );
            char const* processCommandLineArgs[5] = { m_context.m_compilerExecutablePath.c_str(), "-compile", m_pRequest->m_compilerArgs.c_str(), nullptr, nullptr };

            // Set package flag for packing request
            if ( m_pRequest->m_origin == CompilationRequest::Origin::Package )
            {
                processCommandLineArgs[3] = "-package";
            }

            // Start compiler process
            //-------------------------------------------------------------------------

            m_pRequest->m_compilationTimeStarted = PlatformClock::GetTime();

            int32_t result = subprocess_create( processCommandLineArgs, subprocess_option_combined_stdout_stderr | subprocess_option_inherit_environment | subprocess_option_no_window, &m_subProcess );
            if ( result != 0 )
            {
                m_pRequest->m_status = CompilationRequest::Status::Failed;
                m_pRequest->m_log = "Resource compiler failed to start!";
                m_pRequest->m_compilationTimeFinished = PlatformClock::GetTime();
                return;
            }

            // Wait for compilation to complete
            //-------------------------------------------------------------------------

            int32_t exitCode;
            result = subprocess_join( &m_subProcess, &exitCode );
            if ( result != 0 )
            {
                m_pRequest->m_status = CompilationRequest::Status::Failed;
                m_pRequest->m_log = "Resource compiler failed to complete!";
                m_pRequest->m_compilationTimeFinished = PlatformClock::GetTime();
                subprocess_destroy( &m_subProcess );
                return;
            }

            // Handle completed compilation
            //-------------------------------------------------------------------------

            m_pRequest->m_compilationTimeFinished = PlatformClock::GetTime();

            switch ( exitCode )
            {
                case 0:
                {
                    m_pRequest->m_status = CompilationRequest::Status::Succeeded;
                }
                break;

                case 1:
                {
                    m_pRequest->m_status = CompilationRequest::Status::SucceededWithWarnings;
                }
                break;

                default:
                {
                    m_pRequest->m_status = CompilationRequest::Status::Failed;
                }
                break;
            }

            // Read error and output of process
            //-------------------------------------------------------------------------

            char readBuffer[512];
            while ( fgets( readBuffer, 512, subprocess_stdout( &m_subProcess ) ) )
            {
                m_pRequest->m_log += readBuffer;
            }

            //-------------------------------------------------------------------------

            subprocess_destroy( &m_subProcess );
        }

    private:

        ResourceServerContext const&                        m_context;
        Threading::LockFreeQueue<CompilationTask*>&         m_completedTaskQueue;
        CompilationRequest*                                 m_pRequest = nullptr;
        subprocess_s                                        m_subProcess;
    };

    //-------------------------------------------------------------------------

    ResourceServer::~ResourceServer()
    {
        EE_ASSERT( m_pCompilerRegistry == nullptr );
    }

    bool ResourceServer::Initialize( IniFile const& iniFile )
    {
        EE_ASSERT( iniFile.IsValid() );

        if ( !m_settings.ReadSettings( iniFile ) )
        {
            return false;
        }

        // Register types
        //-------------------------------------------------------------------------

        AutoGenerated::Tools::RegisterTypes( m_typeRegistry );

        m_pCompilerRegistry = EE::New<CompilerRegistry>( m_typeRegistry, m_settings.m_rawResourcePath );

        // Connect to compiled resource database
        //-------------------------------------------------------------------------

        if ( !m_compiledResourceDatabase.TryConnect( m_settings.m_compiledResourceDatabasePath ) )
        {
            m_errorMessage.sprintf( "Database connection error: %s", m_compiledResourceDatabase.GetError().c_str() );
            return false;
        }

        // Open network connection
        //-------------------------------------------------------------------------

        if ( !Network::NetworkSystem::Initialize() )
        {
            return false;
        }

        if ( !Network::NetworkSystem::StartServerConnection( &m_networkServer, m_settings.m_resourceServerPort ) )
        {
            return false;
        }

        //-------------------------------------------------------------------------

        if ( m_fileSystemWatcher.StartWatching( m_settings.m_rawResourcePath ) )
        {
            m_fileSystemWatcher.RegisterChangeListener( this );
        }

        // Create Workers
        //-------------------------------------------------------------------------

        m_taskSystem.Initialize();

        m_context.m_rawResourcePath = m_settings.m_rawResourcePath;
        m_context.m_compiledResourcePath = m_settings.m_compiledResourcePath;
        m_context.m_compilerExecutablePath = m_settings.m_resourceCompilerExecutablePath;
        m_context.m_pTypeRegistry = &m_typeRegistry;
        m_context.m_pCompilerRegistry = m_pCompilerRegistry;
        m_context.m_pCompiledResourceDB = &m_compiledResourceDatabase;

        // Packaging
        //-------------------------------------------------------------------------

        RefreshAvailableMapList();

        return true;
    }

    void ResourceServer::Shutdown()
    {
        m_context.m_isExiting = true;

        // Complete all scheduled requests
        //-------------------------------------------------------------------------

        m_taskSystem.WaitForAll();
        ProcessCompletedRequests();
        m_taskSystem.Shutdown();

        EE_ASSERT( m_numScheduledTasks == 0 );

        // Unregister File Watcher
        //-------------------------------------------------------------------------

        if ( m_fileSystemWatcher.IsWatching() )
        {
            m_fileSystemWatcher.StopWatching();
            m_fileSystemWatcher.UnregisterChangeListener( this );
        }

        // Delete requests
        //-------------------------------------------------------------------------

        for ( auto& pRequest : m_requests )
        {
            EE::Delete( pRequest );
        }

        //-------------------------------------------------------------------------

        Network::NetworkSystem::StopServerConnection( &m_networkServer );
        Network::NetworkSystem::Shutdown();

        //-------------------------------------------------------------------------

        EE::Delete( m_pCompilerRegistry );

        AutoGenerated::Tools::UnregisterTypes( m_typeRegistry );
    }

    //-------------------------------------------------------------------------

    void ResourceServer::Update()
    {
        // Update network server
        //-------------------------------------------------------------------------

        Network::NetworkSystem::Update();

        if ( m_networkServer.IsRunning() )
        {
            auto ProcessIncomingMessages = [this] ( Network::IPC::Message const& message )
            {
                if ( message.GetMessageID() == (int32_t) NetworkMessageID::RequestResource )
                {
                    uint32_t const clientID = message.GetClientConnectionID();
                    NetworkResourceRequest networkRequest = message.GetData<NetworkResourceRequest>();
                    CreateResourceRequest( networkRequest.m_path, clientID );
                }
            };

            m_networkServer.ProcessIncomingMessages( ProcessIncomingMessages );
        }

        // Process completed requests
        //-------------------------------------------------------------------------
        
        ProcessCompletedRequests();
        
        // Process cleanup request
        //-------------------------------------------------------------------------

        if ( m_cleanupRequested )
        {
            for ( int32_t i = int32_t( m_requests.size() ) - 1; i >= 0; i-- )
            {
                if ( m_requests[i]->IsComplete() )
                {
                    EE::Delete( m_requests[i] );
                    m_requests.erase( m_requests.begin() + i );
                }
            }

            m_cleanupRequested = false;
        }

        // Update File System Watcher
        //-------------------------------------------------------------------------

        if ( m_fileSystemWatcher.IsWatching() )
        {
            m_fileSystemWatcher.Update();
        }

        // Packaging
        //-------------------------------------------------------------------------

        if ( m_isPackaging )
        {
            if ( m_completedPackagingRequests.size() == m_resourcesToBePackaged.size() )
            {
                m_resourcesToBePackaged.clear();
                m_completedPackagingRequests.clear();
                m_isPackaging = false;
            }
        }
    }

    bool ResourceServer::IsBusy() const
    {
        return m_numScheduledTasks != 0;
    }

    void ResourceServer::OnFileModified( FileSystem::Path const& filePath )
    {
        EE_ASSERT( filePath.IsValid() && filePath.IsFilePath() );

        ResourcePath resourcePath = ResourcePath::FromFileSystemPath( m_settings.m_rawResourcePath, filePath );
        if ( !resourcePath.IsValid() )
        {
            return;
        }

        ResourceID resourceID( resourcePath );
        if ( !resourceID.IsValid() )
        {
            return;
        }

        // If we have a record, then schedule a recompile task
        CreateResourceRequest( resourceID, 0, CompilationRequest::Origin::FileWatcher );
    }

    //-------------------------------------------------------------------------

    void ResourceServer::CreateResourceRequest( ResourceID const& resourceID, uint32_t clientID, CompilationRequest::Origin origin )
    {
        EE_ASSERT( m_compiledResourceDatabase.IsConnected() );

        CompilationRequest* pRequest = EE::New<CompilationRequest>();

        if ( resourceID.IsValid() )
        {
            if ( origin == CompilationRequest::Origin::External )
            {
                EE_ASSERT( clientID != 0 );
            }
            else
            {
                EE_ASSERT( clientID == 0 );
            }

            //-------------------------------------------------------------------------

            pRequest->m_clientID = clientID;
            pRequest->m_origin = origin;
            pRequest->m_resourceID = resourceID;
            pRequest->m_sourceFile = ResourcePath::ToFileSystemPath( m_settings.m_rawResourcePath, pRequest->m_resourceID.GetResourcePath() );
            pRequest->m_compilerArgs = pRequest->m_resourceID.GetResourcePath().c_str();
            pRequest->m_status = CompilationRequest::Status::Pending;

            // Set the destination path based on request type
            if ( origin == CompilationRequest::Origin::Package )
            {
                pRequest->m_destinationFile = ResourcePath::ToFileSystemPath( m_settings.m_packagedBuildCompiledResourcePath, pRequest->m_resourceID.GetResourcePath() );
            }
            else
            {
                pRequest->m_destinationFile = ResourcePath::ToFileSystemPath( m_settings.m_compiledResourcePath, pRequest->m_resourceID.GetResourcePath() );
            }
        }
        else // Invalid resource ID
        {
            pRequest->m_log.sprintf( "Error: Invalid resource ID ( %s )", resourceID.c_str() );
            pRequest->m_status = CompilationRequest::Status::Failed;
        }

        // Enqueue new request
        //-------------------------------------------------------------------------

        m_requests.emplace_back( pRequest );
        auto pTask = EE::New<CompilationTask>( m_context, m_completedTasks, pRequest );
        m_taskSystem.ScheduleTask( pTask );
        m_numScheduledTasks++;
    }

    void ResourceServer::ProcessCompletedRequests()
    {
        CompilationTask* dequeuedTasks[100];
        size_t numDequeuedTasks = m_completedTasks.try_dequeue_bulk( dequeuedTasks, 100 );
        while ( numDequeuedTasks != 0 )
        {
            for ( size_t i = 0; i < numDequeuedTasks; i++ )
            {
                auto pRequest = dequeuedTasks[i]->GetRequest();
                EE_ASSERT( pRequest->IsComplete() );

                // Update database
                if ( pRequest->HasSucceeded() )
                {
                    CompiledResourceRecord record;
                    record.m_resourceID = pRequest->m_resourceID;
                    record.m_compilerVersion = pRequest->m_compilerVersion;
                    record.m_fileTimestamp = pRequest->m_fileTimestamp;
                    record.m_sourceTimestampHash = pRequest->m_sourceTimestampHash;
                    m_compiledResourceDatabase.WriteRecord( record );
                }

                // Send network response
                if ( !m_context.m_isExiting )
                {
                    NotifyClientOnCompletedRequest( pRequest );
                }

                // Delete task
                EE::Delete( dequeuedTasks[i] );

                // Decrement task counter
                m_numScheduledTasks--;
            }

            numDequeuedTasks = m_completedTasks.try_dequeue_bulk( dequeuedTasks, 100 );
        }
    }

    void ResourceServer::NotifyClientOnCompletedRequest( CompilationRequest* pRequest )
    {
        EE_ASSERT( !m_context.m_isExiting );
        EE_ASSERT( pRequest->IsComplete() );

        //-------------------------------------------------------------------------

        NetworkResourceResponse response;
        response.m_resourceID = pRequest->GetResourceID();
        if ( pRequest->HasSucceeded() )
        {
            response.m_filePath = pRequest->GetDestinationFilePath();
        }

        //-------------------------------------------------------------------------

        // Notify all clients
        if ( pRequest->IsInternalRequest() )
        {
            // Remove from list of resources being packaged since the request is complete
            if ( pRequest->m_origin == CompilationRequest::Origin::Package )
            {
                m_completedPackagingRequests.emplace_back( pRequest->m_resourceID );
            }

            // Bulk notify all connected client that a resource has been recompiled so that they can reload it if necessary
            for ( auto const& clientInfo : m_networkServer.GetConnectedClients() )
            {
                Network::IPC::Message message;
                message.SetClientConnectionID( clientInfo.m_ID );
                message.SetData( (int32_t) NetworkMessageID::ResourceUpdated, response );
                m_networkServer.SendNetworkMessage( eastl::move( message ) );
            }
        }
        else // Notify single client
        {
            Network::IPC::Message message;
            message.SetClientConnectionID( pRequest->GetClientID() );
            message.SetData( (int32_t) NetworkMessageID::ResourceRequestComplete, response );
            m_networkServer.SendNetworkMessage( eastl::move( message ) );
        }
    }

    //-------------------------------------------------------------------------

    void ResourceServer::RefreshAvailableMapList()
    {
        m_allMaps.clear();

        TVector<FileSystem::Path> results;
        if ( FileSystem::GetDirectoryContents( m_settings.m_rawResourcePath, results, FileSystem::DirectoryReaderOutput::OnlyFiles, FileSystem::DirectoryReaderMode::Expand, { "map" } ) )
        {
            for ( auto const& foundMapPath : results )
            {
                m_allMaps.emplace_back( ResourceID::FromFileSystemPath( m_settings.m_rawResourcePath, foundMapPath ) );
            }
        }
    }

    void ResourceServer::StartPackaging()
    {
        EE_ASSERT( !m_isPackaging && m_resourcesToBePackaged.empty() );
        m_completedPackagingRequests.clear();

        // Package Module Resources
        //-------------------------------------------------------------------------
        // TODO: is there a less error prone mechanism for this?

        EngineModule::GetListOfAllRequiredModuleResources( m_resourcesToBePackaged );
        GameModule::GetListOfAllRequiredModuleResources( m_resourcesToBePackaged );

        // Package Selected Maps
        //-------------------------------------------------------------------------

        for ( auto const& mapID : m_mapsToBePackaged )
        {
            EnqueueResourceForPackaging( mapID );
        }

        for ( auto const& resourceID : m_resourcesToBePackaged )
        {
            CreateResourceRequest( resourceID, 0, CompilationRequest::Origin::Package );
        }

        m_isPackaging = true;
    }

    bool ResourceServer::CanStartPackaging() const
    {
        return !m_mapsToBePackaged.empty();
    }

    void ResourceServer::AddMapToPackagingList( ResourceID mapResourceID )
    {
        EE_ASSERT( mapResourceID.GetResourceTypeID() == EntityModel::SerializedEntityMap::GetStaticResourceTypeID() );
        VectorEmplaceBackUnique( m_mapsToBePackaged, mapResourceID );
    }

    void ResourceServer::RemoveMapFromPackagingList( ResourceID mapResourceID )
    {
        EE_ASSERT( mapResourceID.GetResourceTypeID() == EntityModel::SerializedEntityMap::GetStaticResourceTypeID() );
        m_mapsToBePackaged.erase_first_unsorted( mapResourceID );
    }

    void ResourceServer::EnqueueResourceForPackaging( ResourceID const& resourceID )
    {
        auto pCompiler = m_pCompilerRegistry->GetCompilerForResourceType( resourceID.GetResourceTypeID() );
        if ( pCompiler != nullptr )
        {
            // Add resource for packaging
            VectorEmplaceBackUnique( m_resourcesToBePackaged, resourceID );

            // Get all referenced resources
            TVector<ResourceID> referencedResources;
            pCompiler->GetReferencedResources( resourceID, referencedResources );

            // Recursively enqueue all referenced resources
            for ( auto const& referenceResourceID : referencedResources )
            {
                EnqueueResourceForPackaging( referenceResourceID );
            }
        }
    }
}