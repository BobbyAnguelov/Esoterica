#include "Base/ThirdParty/cmdParser/cmdParser.h"
#include <vector>
#include <filesystem>
#include <iostream>
#include <fstream>

//-------------------------------------------------------------------------

namespace fs = std::filesystem;

//-------------------------------------------------------------------------
// Global
//-------------------------------------------------------------------------

#define ASSERT( cond ) do { if( !( cond ) ) { __debugbreak(); } } while( 0 )

static char g_preferredFileSeparator[10] = { 0 };

static std::string s_autogeneratedDirectoryRelativePath;

//-------------------------------------------------------------------------
// Platforms and Configs
//-------------------------------------------------------------------------

constexpr static char const* const g_platforms[] = { "x64" };
constexpr static size_t const g_numPlatforms = sizeof( g_platforms ) / sizeof( char* );

constexpr static char const* const g_configs[] = { "Debug", "Release", "Shipping" };
constexpr static size_t const g_numConfigs = sizeof( g_configs ) / sizeof( char* );

//-------------------------------------------------------------------------
// File Types
//-------------------------------------------------------------------------

struct GlobalPaths
{
    fs::path m_slnDirectoryPath;
    fs::path m_codeDirectoryPath;
    fs::path m_buildDirectoryPath;
};

//-------------------------------------------------------------------------

class ProjectFile
{
public:

    ProjectFile() = default;

    ProjectFile( GlobalPaths const& globalPaths, fs::path const& prjDirectoryPath, fs::path const& fullPath )
        : m_fullPath( fullPath )
    {
        m_projectRelativePath = fs::relative( fullPath, prjDirectoryPath ).string();
        m_codeRelativePath = fs::relative( fullPath, globalPaths.m_codeDirectoryPath ).string();
        m_solutionRelativePath = fs::relative( fullPath, globalPaths.m_slnDirectoryPath ).string();
    }

    virtual ~ProjectFile() = default;

    virtual void GenerateRule( GlobalPaths const& globalPaths, class Project const& project, std::stringstream& outStream ) const = 0;

public:

    std::string                 m_projectRelativePath;
    std::string                 m_codeRelativePath;
    std::string                 m_solutionRelativePath;
    fs::path                    m_fullPath;
};

//-------------------------------------------------------------------------

class Project
{
public:

    Project() = default;

    Project( std::string const& name, fs::path const& projectFilePath )
        : m_name( name )
        , m_projectFilePath( projectFilePath )
        , m_directoryPath( projectFilePath.parent_path() )
    {}

    bool Parse( GlobalPaths const& globalPaths );

    bool GenerateBuildRules( GlobalPaths const& globalPaths, std::stringstream& stream )
    {
        for ( ProjectFile const* pFile : m_files )
        {
            pFile->GenerateRule( globalPaths, *this, stream );
        }

        return true;
    }

    void Clear()
    {
        m_name.clear();
        m_directoryPath.clear();

        for ( auto pFile : m_files )
        {
            delete pFile;
        }
        m_files.clear();
    }

private:

    template<typename T>
    void TryParseFile( GlobalPaths const& globalPaths, std::ifstream& fileStream, std::string& line )
    {
        auto pNewFile = T::TryParse( globalPaths, m_directoryPath, fileStream, line );
        if ( pNewFile != nullptr )
        {
            m_files.emplace_back( pNewFile );
        }
    }

public:

    std::string                     m_name;
    fs::path                        m_projectFilePath;
    fs::path                        m_directoryPath;
    std::vector<ProjectFile*>       m_files;
};

//-------------------------------------------------------------------------

class CPP : public ProjectFile
{
public:

    using ProjectFile::ProjectFile;

    static ProjectFile* TryParse( GlobalPaths const& globalPaths, fs::path const& prjDirectoryPath, std::ifstream& projectFileStream, std::string& line )
    {
        size_t firstIdx = line.find( "<ClCompile" );
        if ( firstIdx != std::string::npos )
        {
            firstIdx = line.find( "Include=\"" );
            if ( firstIdx == std::string::npos )
            {
                return nullptr;
            }

            firstIdx += 9;
            size_t secondIdx = line.find( "\"", firstIdx );
            if ( secondIdx == std::string::npos )
            {
                return nullptr;
            }

            fs::path const fullPath = prjDirectoryPath / line.substr( firstIdx, secondIdx - firstIdx );
            return new CPP( globalPaths, prjDirectoryPath, fullPath );
        }

        return nullptr;
    }

    virtual void GenerateRule( GlobalPaths const& globalPaths, Project const& project, std::stringstream& outStream ) const override
    {
        for ( int32_t p = 0; p < g_numPlatforms; p++ )
        {
            for ( int32_t c = 0; c < g_numConfigs; c++ )
            {
                outStream << g_platforms[p] << "_" << g_configs[c] << g_preferredFileSeparator << m_codeRelativePath << ".obj: ";
                outStream << "cxx_" << project.m_name << "_" << g_configs[c] << " " << m_fullPath.string() << std::endl;
                outStream << "    pdb = " << project.m_name << ".pdb" << std::endl << std::endl;
            }
        }
    }
};

//-------------------------------------------------------------------------
// Generator
//-------------------------------------------------------------------------

bool Project::Parse( GlobalPaths const& globalPaths )
{
    ASSERT( fs::exists( m_directoryPath ) );

    std::ifstream fileStream( m_projectFilePath );
    if ( !fileStream.is_open() )
    {
        std::cout << "Error: Could not open project file: " << m_projectFilePath << std::endl;
        return false;
    }

    std::string line;
    while ( std::getline( fileStream, line ) )
    {
        TryParseFile<CPP>( globalPaths, fileStream, line );
    }

    fileStream.close();

    // Autogenerated Files
    //-------------------------------------------------------------------------

    fs::path const autogeneratedPath = m_directoryPath / s_autogeneratedDirectoryRelativePath;
    if ( fs::exists( autogeneratedPath ) && fs::is_directory( autogeneratedPath ) )
    {
        for ( auto const& entry : fs::directory_iterator( autogeneratedPath ) )
        {
            fs::path const& filePath = entry.path();
            if ( filePath.extension() == ".cpp" || filePath.extension() == ".cxx" )
            {
                m_files.emplace_back( new CPP( globalPaths, m_directoryPath, filePath ) );
            }
        }
    }

    return true;
}

static bool ParseSolutionAndGenerateBuildFile( fs::path const& slnFilePath )
{
    if ( !slnFilePath.has_filename() || slnFilePath.extension() != ".sln" )
    {
        std::cout << "Error: " << slnFilePath << std::endl;
        return false;
    }

    if ( !fs::exists( slnFilePath ) )
    {
        std::cout << "Error: Solution doesnt exist:" << slnFilePath;
        return false;
    }

    GlobalPaths globalPaths;
    globalPaths.m_slnDirectoryPath = slnFilePath.parent_path();
    globalPaths.m_codeDirectoryPath = globalPaths.m_slnDirectoryPath / "Code";
    globalPaths.m_buildDirectoryPath = globalPaths.m_slnDirectoryPath / "Build";

    if ( !fs::is_directory( globalPaths.m_codeDirectoryPath ) )
    {
        std::cout << "Error: Invalid output code directory name: " << globalPaths.m_codeDirectoryPath << std::endl;
        return false;
    }

    if ( !fs::is_directory( globalPaths.m_buildDirectoryPath ) )
    {
        std::cout << "Error: Invalid output build directory name: " << globalPaths.m_buildDirectoryPath << std::endl;
        return false;
    }

    // Parse Solution
    //-------------------------------------------------------------------------

    std::ifstream slnFile( slnFilePath );
    if ( !slnFile.is_open() )
    {
        std::cout << "Error: Could not open solution: " << slnFilePath << std::endl;
        return false;
    }

    fs::path const solutionRootDir = slnFilePath.parent_path();

    std::vector<Project> projects;

    std::string line;
    while ( std::getline( slnFile, line ) )
    {
        if ( line.find( "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}" ) != std::string::npos ) // VS Project UID
        {
            auto projectNameStartIdx = line.find( " = \"" );
            ASSERT( projectNameStartIdx != std::string::npos );
            projectNameStartIdx += 4;
            auto projectNameEndIdx = line.find( "\", \"", projectNameStartIdx );
            ASSERT( projectNameEndIdx != std::string::npos );

            auto projectPathStartIdx = projectNameEndIdx + 4;
            ASSERT( projectPathStartIdx < line.length() );
            auto projectPathEndIdx = line.find( "\"", projectPathStartIdx );
            ASSERT( projectNameEndIdx != std::string::npos );

            std::string const projectName = line.substr( projectNameStartIdx, projectNameEndIdx - projectNameStartIdx );
            std::string const projectPathString = line.substr( projectPathStartIdx, projectPathEndIdx - projectPathStartIdx );
            fs::path const projectPath = solutionRootDir / projectPathString;
            ASSERT( fs::exists( projectPath ) );
            projects.emplace_back( projectName, projectPath );
        }
    }

    slnFile.close();

    //-------------------------------------------------------------------------

    auto Cleanup = [&] ()
    {
        for ( Project& project : projects )
        {
            project.Clear();
        }
    };

    for ( auto& project : projects )
    {
        if ( !project.Parse( globalPaths ) )
        {
            std::cout << "Error: Failed parse project: " << project.m_projectFilePath << std::endl;
            Cleanup();
            return false;
        }
    }

    std::cout << " * Parsing Complete!" << std::endl;

    // Generate ninja file
    //-------------------------------------------------------------------------

    std::stringstream buildFileStream;
    for ( auto& project : projects )
    {
        project.GenerateBuildRules( globalPaths, buildFileStream );
    }

    fs::path const buildFilePath = globalPaths.m_buildDirectoryPath / "Esoterica.ninja";
    std::fstream outputFile( buildFilePath.c_str(), std::ios::out | std::ios::trunc );
    if ( !outputFile.is_open() )
    {
        std::cout << "Error: Failed to open build file for write: " << buildFilePath << std::endl;
        Cleanup();
        return false;
    }

    buildFileStream.seekg( std::ios::beg );
    outputFile << buildFileStream.rdbuf();
    outputFile.close();

    Cleanup();

    std::cout << " * Generation Complete!" << std::endl;
    return true;
}

int main( int argc, char *argv[] )
{
    // Get char representation of file path delimiter
    //-------------------------------------------------------------------------

    wctomb( g_preferredFileSeparator, fs::path::preferred_separator );
    s_autogeneratedDirectoryRelativePath = std::string( "_Module" ) + g_preferredFileSeparator + "_Autogenerated";

    // Set precision of cout
    //-------------------------------------------------------------------------

    std::cout.setf( std::ios::fixed, std::ios::floatfield );
    std::cout.precision( 2 );

    // Read CMD line arguments
    //-------------------------------------------------------------------------

    cli::Parser cmdParser( argc, argv );
    cmdParser.set_required<std::string>( "s", "SlnPath", "Solution Path." );

    if ( !cmdParser.run() )
    {
        std::cout << std::endl << "Error: Invalid command line arguments" << std::endl;
        return 1;
    }

    fs::path const slnPath = cmdParser.get<std::string>( "s" ).c_str();

    // Execute reflector
    //-------------------------------------------------------------------------

    std::cout << std::endl;
    std::cout << "===============================================" << std::endl;
    std::cout << " Esoterica Build Generator" << std::endl;
    std::cout << "===============================================" << std::endl;
    std::cout << " " << slnPath.string() << " -> " << slnPath.parent_path().string() << g_preferredFileSeparator << "Build" << g_preferredFileSeparator << "Esoterica.ninja" << std::endl << std::endl;

    // Parse solution
    if ( !ParseSolutionAndGenerateBuildFile( slnPath ) )
    {
        return 1;
    }

    return 0;
}