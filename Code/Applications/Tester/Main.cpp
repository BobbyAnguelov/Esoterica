#include "Base/TypeSystem/TypeRegistry.h"
#include "Base/Application/ApplicationGlobalState.h"
#include "Base/FileSystem/FileSystem.h"
#include "Base/Serialization/BinarySerialization.h"
#include "Base/Math/NumericRange.h"
#include "Base/Types/Event.h"

#include "_AutoGenerated/ToolsTypeRegistration.h"

#include <iostream>
#include "Base/Network/IPC/IPCMessage.h"
#include "Base/Math/MathRandom.h"
#include "Base/Time/Timers.h"
#include "Base/Encoding/Quantization.h"

//-------------------------------------------------------------------------

using namespace EE;

//-------------------------------------------------------------------------

EE_FORCE_INLINE float Dot( Float3 const& a, Float3 const& b )
{
    float const d = ( a.m_x * b.m_x ) + ( a.m_y * b.m_y ) + ( a.m_z * b.m_z );
    return d;
}

EE_FORCE_INLINE Float3 Cross3( Float3 const& a, Float3 const& b )
{
    float x = ( a.m_y * b.m_z ) - ( a.m_z * b.m_y );
    float y = ( a.m_z * b.m_x ) - ( a.m_x * b.m_z );
    float z = ( a.m_x * b.m_y ) - ( a.m_y * b.m_x );
    return Float3( x, y, z );
}

EE_FORCE_INLINE Float4 QuatMul( Float4 const &a, Float4 const& b )
{
   return Float4(
            ( b.m_w * a.m_x ) + ( b.m_x * a.m_w ) + ( b.m_y * a.m_z ) - ( b.m_z * a.m_y ),
            ( b.m_w * a.m_y ) - ( b.m_x * a.m_z ) + ( b.m_y * a.m_w ) + ( b.m_z * a.m_x ),
            ( b.m_w * a.m_z ) + ( b.m_x * a.m_y ) - ( b.m_y * a.m_x ) + ( b.m_z * a.m_w ),
            ( b.m_w * a.m_w ) - ( b.m_x * a.m_x ) - ( b.m_y * a.m_y ) - ( b.m_z * a.m_z )
        );
}

//-------------------------------------------------------------------------

class C
{
    int32_t x = 18;
    int32_t y = 18;
    int32_t z = 18;
    int32_t w = 18;
};

template<class M, class Secret>
struct public_cast
{
    static inline M m{};
};

template<class Secret, auto M>
struct access
{
    static const inline auto m = public_cast<decltype(M), Secret>::m = M;
};

//-------------------------------------------------------------------------

template struct access<class CxSecret, &C::x>;
template struct access<class CxSecret, &C::y>;
template struct access<class CxSecret, &C::z>;
template struct access<class CxSecret, &C::w>;

//-------------------------------------------------------------------------

int main( int argc, char *argv[] )
{
    {
        EE::ApplicationGlobalState State;
        TypeSystem::TypeRegistry typeRegistry;
        TypeSystem::Reflection::RegisterTypes( typeRegistry );

        //-------------------------------------------------------------------------
        
        Quaternion q( 0.851569f, -0.522476f, 0.010197f, 0.0417675f );
        Quantization::EncodedQuaternion eq( q );
        Quaternion dq = eq.ToQuaternion();

        //-------------------------------------------------------------------------

        //constexpr static int32_t const size = 10000;

        //Float4 s[size];
        //Float4 sR[size];

        //for ( int32_t i = 0; i < size; i++ )
        //{
        //    s[i] = Float4( Math::GetRandomFloat( -20000, 20000 ), Math::GetRandomFloat( -20000, 20000 ), Math::GetRandomFloat( -20000, 20000 ), Math::GetRandomFloat( -20000, 20000 ) );
        //}

        //Quaternion v[size];
        //Quaternion vR[size];

        //for ( int32_t i = 0; i < size; i++ )
        //{
        //    v[i] = Quaternion( s[i] );
        //}

        ////-------------------------------------------------------------------------

        //Milliseconds time;

        //{
        //    ScopedTimer<PlatformClock> t( time );

        //    for ( int32_t j = 0; j < 100000; j++ )
        //    {
        //        for ( int32_t i = 0; i < ( size - 1 ); i++ )
        //        {
        //            sR[i] = QuatMul( s[i], s[i+1] );
        //        }
        //    }
        //}

        //std::cout << "Scalar: " << time.ToFloat() << "ms" << std::endl;
        //std::cout << sR[340].m_y << std::endl;

        ////-------------------------------------------------------------------------

        //{
        //    ScopedTimer<PlatformClock> t( time );

        //    for ( int32_t j = 0; j < 100000; j++ )
        //    {
        //        for ( int32_t i = 0; i < ( size - 1 ); i++ )
        //        {
        //            vR[i] = v[i] * v[i + 1];
        //        }
        //    }
        //}
        //
        //std::cout << "Vector: " << time.ToFloat() << "ms" << std::endl;

        //-------------------------------------------------------------------------

        TypeSystem::Reflection::UnregisterTypes( typeRegistry );
    }

    return 0;
}