#include "_AutoGenerated/ToolsTypeRegistration.h"
#include "EngineTools/Resource/ResourceCompilerRegistry.h"
#include "Applications/Shared/ApplicationGlobalState.h"
#include "Applications/Shared/cmdParser/cmdParser.h"
#include "System/Resource/ResourceSettings.h"
#include "System/FileSystem/FileSystemUtils.h"
#include "System/IniFile.h"
#include "System/Log.h"

#include <windows.h>
#include <iostream>

//-------------------------------------------------------------------------

using namespace EE;

//-------------------------------------------------------------------------
// Command Line Argument Parsing
//-------------------------------------------------------------------------

namespace EE
{
    struct CommandLineArgumentParser
    {
        CommandLineArgumentParser( int argc, char* argv[] )
        {
            cli::Parser cmdParser( argc, argv );
            cmdParser.set_default<bool>( false );
            cmdParser.set_optional<std::string>( "compile", "compile", "", "Compile resource" );
            cmdParser.set_optional<bool>( "debug", "debug", false, "Trigger debug break before execution." );
            cmdParser.set_optional<bool>( "package", "package", false, "Compile resource for packaged build." );

            if ( cmdParser.run() )
            {
                m_triggerDebugBreak = cmdParser.get<bool>( "debug" );
                m_isForPackagedBuild = cmdParser.get<bool>( "package" );

                // Get compile argument
                ResourcePath const resourcePath( cmdParser.get<std::string>( "compile" ).c_str() );
                if ( resourcePath.IsValid() )
                {
                    m_resourceID = ResourceID( resourcePath );

                    if ( m_resourceID.IsValid() )
                    {
                        m_isValid = true;
                    }
                    else
                    {
                        EE_LOG_ERROR( "Resource", "Resource Compiler", "Invalid compile request: %s\n", m_resourceID.ToString().c_str() );
                    }

                    return;
                }
            }
        }

        bool IsValid() const { return m_isValid; }

    public:

        ResourceID          m_resourceID;
        bool                m_triggerDebugBreak = false;
        bool                m_isForPackagedBuild = false;
        bool                m_isValid = false;
    };
}

//-------------------------------------------------------------------------
// Application Entry Point
//-------------------------------------------------------------------------

int main( int argc, char* argv[] )
{
    ApplicationGlobalState State;

    // Read INI settings
    //-------------------------------------------------------------------------

    FileSystem::Path const iniFilePath = FileSystem::GetCurrentProcessPath().Append( "Esoterica.ini" );
    IniFile iniFile( iniFilePath );
    if ( !iniFile.IsValid() )
    {
        EE_LOG_ERROR( "Resource", "Resource Compiler", "Failed to read INI file: %s", iniFilePath.c_str() );
        return 1;
    }

    Resource::ResourceSettings settings;
    if ( !settings.ReadSettings( iniFile ) )
    {
        EE_LOG_ERROR( "Resource", "Resource Compiler", "Failed to read settings from INI file: %s", iniFilePath.c_str() );
        return false;
    }

    // Read CMD line arguments and process request
    //-------------------------------------------------------------------------

    CommandLineArgumentParser argParser( argc, argv );

    for ( int i = 0; i < argc; i++ )
    {
        std::cout << argv[i] << std::endl;
    }

    if ( !argParser.IsValid() )
    {
        EE_LOG_ERROR( "Resource", "Resource Compiler", "Invalid command line arguments" );
        return 1;
    }

    // File Paths
    //-------------------------------------------------------------------------

    if ( argParser.m_isForPackagedBuild )
    {
        settings.m_compiledResourcePath = settings.m_packagedBuildCompiledResourcePath;
    }

    settings.m_rawResourcePath.EnsureDirectoryExists();
    settings.m_compiledResourcePath.EnsureDirectoryExists();

    // Create tools modules and register compilers
    //-------------------------------------------------------------------------

    TypeSystem::TypeRegistry typeRegistry;
    AutoGenerated::Tools::RegisterTypes( typeRegistry );

    Resource::CompilerRegistry compilerRegistry( typeRegistry, settings.m_rawResourcePath );


    // Execute compilation command
    //-------------------------------------------------------------------------

    // Debug break
    if ( argParser.m_triggerDebugBreak )
    {
        EE_HALT();
    }

    auto CompileResource = [&] ()
    {
        // Try create compilation context
        Resource::CompileContext compileContext( settings.m_rawResourcePath, settings.m_compiledResourcePath, argParser.m_resourceID, argParser.m_isForPackagedBuild );
        if ( !compileContext.IsValid() )
        {
            return -1;
        }

        // Try find compiler
        auto pCompiler = compilerRegistry.GetCompilerForResourceType( compileContext.m_resourceID.GetResourceTypeID() );
        if ( pCompiler == nullptr )
        {
            EE_LOG_ERROR( "Resource", "Resource Compiler", "Cant find appropriate resource compiler for type: %u", compileContext.m_resourceID.GetResourceTypeID() );
            return -1;
        }

        // Validate input path
        if ( pCompiler->IsInputFileRequired() && !FileSystem::Exists( compileContext.m_inputFilePath ) )
        {
            EE_LOG_ERROR( "Resource", "Resource Compiler", "Source file for data path ('%s') does not exist: '%s'\n", settings.m_rawResourcePath.c_str(), compileContext.m_inputFilePath.c_str() );
            return -1;
        }

        // Compile
        Resource::CompilationResult const result = pCompiler->Compile( compileContext );
        return (int32_t) result;
    };

    int32_t const result = CompileResource();

    // Unregister all types
    //-------------------------------------------------------------------------

    AutoGenerated::Tools::UnregisterTypes( typeRegistry );

    return result;
}