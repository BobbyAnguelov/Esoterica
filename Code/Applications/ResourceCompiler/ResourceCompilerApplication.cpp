#include "ResourceCompilerApplication.h"
#include "CompiledResourceDatabase.h"
#include "EngineTools/_Module/_AutoGenerated/ToolsTypeRegistration.h"
#include "EngineTools/Resource/ResourceCompilerRegistry.h"
#include "Engine/Entity/EntityDescriptors.h"
#include "Base/Application/ApplicationGlobalState.h"
#include "Base/ThirdParty/cmdParser/cmdParser.h"
#include "Base/Time/Time.h"
#include "Base/Time/Timers.h"
#include "Base/Resource/Settings/GlobalSettings_Resource.h"
#include "Base/FileSystem/FileSystemUtils.h"
#include "Base/Settings/IniFile.h"

#include <windows.h>
#include <iostream>

//-------------------------------------------------------------------------
// Command Line Argument Parsing
//-------------------------------------------------------------------------

namespace EE
{
    struct CommandLineArgumentParser
    {
        CommandLineArgumentParser( int argc, char* argv[] )
        {
            cli::Parser cmdParser( argc, argv );
            cmdParser.set_default<bool>( false );
            cmdParser.set_optional<std::string>( "compile", "compile", "", "Compile resource" );
            cmdParser.set_optional<bool>( "debug", "debug", false, "Trigger debug break before execution." );
            cmdParser.set_optional<bool>( "force", "force", false, "Force compilation" );
            cmdParser.set_optional<bool>( "package", "package", false, "Compile resource for packaged build." );

            if ( cmdParser.run() )
            {
                m_triggerDebugBreak = cmdParser.get<bool>( "debug" );
                m_isForcedCompilation = cmdParser.get<bool>( "force" );
                m_isForPackagedBuild = cmdParser.get<bool>( "package" );

                // Get compile argument
                DataPath const resourcePath( cmdParser.get<std::string>( "compile" ).c_str() );
                if ( resourcePath.IsValid() )
                {
                    m_resourceID = ResourceID( resourcePath );

                    if ( m_resourceID.IsValid() )
                    {
                        m_isValid = true;
                    }
                    else
                    {
                        EE_LOG_ERROR( "Resource", "Resource Compiler", "Invalid compile request: %s\n", m_resourceID.ToString().c_str() );
                    }

                    return;
                }
            }
        }

        bool IsValid() const { return m_isValid; }

    public:

        ResourceID          m_resourceID;
        bool                m_triggerDebugBreak = false;
        bool                m_isForPackagedBuild = false;
        bool                m_isForcedCompilation = false;
        bool                m_isValid = false;
    };
}

//-------------------------------------------------------------------------
// Resource Compiler
//-------------------------------------------------------------------------

namespace EE::Resource
{
    void ResourceCompilerApplication::CompileDependencyNode::Reset()
    {
        m_ID.Clear();
        m_compiledRecord.Clear();
        m_sourcePath.Clear();
        m_targetPath.Clear();
        m_timestamp = m_combinedHash = 0;
        m_sourceExists = m_targetExists = false;
        m_errorOccurredReadingDependencies = false;
        m_compilerVersion = -1;
        DestroyDependencies();
    }

    void ResourceCompilerApplication::CompileDependencyNode::DestroyDependencies()
    {
        for ( auto pDep : m_dependencies )
        {
            pDep->DestroyDependencies();
            EE::Delete( pDep );
        }

        m_dependencies.clear();
    }

    bool ResourceCompilerApplication::CompileDependencyNode::IsUpToDate() const
    {
        if ( m_forceRecompile )
        {
            return false;
        }

        //-------------------------------------------------------------------------

        if ( !m_sourceExists )
        {
            return false;
        }

        //-------------------------------------------------------------------------

        if ( IsCompileableResource() )
        {
            if ( !m_targetExists )
            {
                return false;
            }

            if ( !m_compiledRecord.IsValid() )
            {
                return false;
            }

            if ( m_compiledRecord.m_compilerVersion != m_compilerVersion )
            {
                return false;
            }

            if ( m_compiledRecord.m_sourceTimestampHash != m_combinedHash )
            {
                return false;
            }
        }

        //-------------------------------------------------------------------------

        for ( auto const& pDep : m_dependencies )
        {
            if ( !pDep->IsUpToDate() )
            {
                return false;
            }
        }

        //-------------------------------------------------------------------------

        return true;
    }

    //-------------------------------------------------------------------------

    ResourceCompilerApplication::ResourceCompilerApplication()
        : m_settingsRegistry( m_typeRegistry )
    {}

    ResourceCompilerApplication::~ResourceCompilerApplication()
    {
        EE_ASSERT( m_pCompileContext == nullptr );
        EE_ASSERT( m_pCompilerRegistry == nullptr );
        EE_ASSERT( m_pCompilerRegistry == nullptr );
    }

    bool ResourceCompilerApplication::Initialize( CommandLineArgumentParser& argParser, FileSystem::Path const& iniFilePath )
    {
        TypeSystem::Reflection::RegisterTypes( m_typeRegistry );

        // Initialize Settings
        //-------------------------------------------------------------------------

        if ( !m_settingsRegistry.Initialize( iniFilePath ) )
        {
            return false;
        }

        auto const* pSettings = m_settingsRegistry.GetGlobalSettings<Resource::ResourceGlobalSettings>();
        EE_ASSERT( pSettings != nullptr );

        // Connect database
        //-------------------------------------------------------------------------

        if ( !m_compiledResourceDB.Connect( pSettings->m_compiledResourceDatabasePath ) )
        {
            EE_LOG_ERROR( "Resource", "Resource Compiler", "Database connection error: %s", m_compiledResourceDB.GetError().c_str() );
            return false;
        }

        // Create compiler registry
        //-------------------------------------------------------------------------

        m_pCompilerRegistry = EE::New<CompilerRegistry>( m_typeRegistry, pSettings->m_sourceDataDirectoryPath );

        // Setup compile context
        //-------------------------------------------------------------------------

        m_forceCompilation = argParser.m_isForcedCompilation;

        m_pCompileContext = EE::New<CompileContext>( pSettings->m_sourceDataDirectoryPath, argParser.m_isForPackagedBuild ? pSettings->m_packagedBuildCompiledResourceDirectoryPath : pSettings->m_compiledResourceDirectoryPath, argParser.m_resourceID, argParser.m_isForPackagedBuild );
        m_pCompileContext->m_sourceDataDirectoryPath.EnsureDirectoryExists();
        m_pCompileContext->m_compiledResourceDirectoryPath.EnsureDirectoryExists();

        //-------------------------------------------------------------------------

        return true;
    }

    void ResourceCompilerApplication::Shutdown()
    {
        m_compileDependencyTreeRoot.DestroyDependencies();
      
        EE::Delete( m_pCompileContext );

        EE::Delete( m_pCompilerRegistry );

        if ( m_compiledResourceDB.IsConnected() )
        {
            m_compiledResourceDB.Disconnect();
        }

        m_settingsRegistry.Shutdown();

        TypeSystem::Reflection::UnregisterTypes( m_typeRegistry );
    }

    bool ResourceCompilerApplication::ShouldCheckCompileDependenciesForResourceType( ResourceID const& resourceID )
    {
        if ( resourceID.GetResourceTypeID() == ResourceTypeID( "map" ) )
        {
            return false;
        }

        if ( resourceID.GetResourceTypeID() == ResourceTypeID( "nav" ) )
        {
            return false;
        }

        return true;
    }

    CompilationResult ResourceCompilerApplication::Run()
    {
        if ( !m_compiledResourceDB.IsConnected() )
        {
            EE_LOG_ERROR( "Resource", "Resource Compiler", "Database connection error: %s", m_compiledResourceDB.GetError().c_str() );
            return Resource::CompilationResult::Failure;
        }

        // Try create compilation context
        if ( m_pCompileContext != nullptr && !m_pCompileContext->IsValid() )
        {
            return Resource::CompilationResult::Failure;
        }

        // Try find compiler
        auto pCompiler = m_pCompilerRegistry->GetCompilerForResourceType( m_pCompileContext->m_resourceID.GetResourceTypeID() );
        if ( pCompiler == nullptr )
        {
            EE_LOG_ERROR( "Resource", "Resource Compiler", "Cant find appropriate resource compiler for type: %u", m_pCompileContext->m_resourceID.GetResourceTypeID() );
            return Resource::CompilationResult::Failure;
        }

        // Validate request
        //-------------------------------------------------------------------------

        // Validate input path
        if ( pCompiler->IsInputFileRequired() && !FileSystem::Exists( m_pCompileContext->m_inputFilePath ) )
        {
            EE_LOG_ERROR( "Resource", "Resource Compiler", "Source file for data path ('%s') does not exist: '%s'\n", m_pCompileContext->m_sourceDataDirectoryPath.c_str(), m_pCompileContext->m_inputFilePath.c_str() );
            return Resource::CompilationResult::Failure;
        }

        // Try create target directory
        if ( !m_pCompileContext->m_outputFilePath.EnsureDirectoryExists() )
        {
            EE_LOG_ERROR( "Resource", "Resource Compiler", "Error: Destination path (%s) doesnt exist!", m_pCompileContext->m_outputFilePath.GetParentDirectory().c_str() );
            return Resource::CompilationResult::Failure;
        }

        // Check that target file isnt read-only
        if ( FileSystem::Exists( m_pCompileContext->m_outputFilePath ) && FileSystem::IsFileReadOnly( m_pCompileContext->m_outputFilePath ) )
        {
            EE_LOG_ERROR( "Resource", "Resource Compiler", "Error: Destination file (%s) is read-only!", m_pCompileContext->m_outputFilePath.GetFullPath().c_str() );
            return Resource::CompilationResult::Failure;
        }

        // Basic Up-To-Date Check
        //-------------------------------------------------------------------------

        bool requiresCompilation = true;

        Milliseconds upToDateCheckTime = 0.0f;
        {
            ScopedTimer<PlatformClock> upToDateCheckTimer( upToDateCheckTime );

            // Check compile dependency and if this resource needs compilation
            m_uniqueCompileDependencies.clear();
            m_compileDependencyTreeRoot.Reset();
            if ( !FillCompileDependencyNode( &m_compileDependencyTreeRoot, m_pCompileContext->m_resourceID.GetResourcePath() ) )
            {
                EE_LOG_ERROR( "Resource", "Resource Compiler", "Failed to create dependency tree: %s", m_errorMessage.c_str() );
                return Resource::CompilationResult::Failure;
            }

            m_pCompileContext->m_sourceResourceHash = m_compileDependencyTreeRoot.m_combinedHash;
            requiresCompilation = !m_compileDependencyTreeRoot.IsUpToDate();
        }

        EE_LOG_INFO( "Resource", "Resource Compiler", "Up to Date Check took: %.2fms", upToDateCheckTime.ToFloat() );

        // Advanced Up-To-Date Check
        //-------------------------------------------------------------------------

        if ( pCompiler->RequiresAdvancedUpToDateCheck( m_pCompileContext->m_resourceID.GetResourceTypeID() ) )
        {
            Milliseconds advancedUpToDateCheckTime = 0.0f;
            {
                ScopedTimer<PlatformClock> advancedUpToDateCheckTimer( advancedUpToDateCheckTime );
                m_pCompileContext->m_advancedUpToDateHash = pCompiler->CalculateAdvancedUpToDateHash( m_pCompileContext->m_resourceID );
            }

            EE_LOG_INFO( "Resource", "Resource Compiler", "Advanced Up to Date Check took: %.2fms", advancedUpToDateCheckTime.ToFloat() );

            // Only take into account the advanced check when we failed the basic check
            if ( requiresCompilation )
            {
                CompiledResourceRecord compiledRecord;
                if ( m_compiledResourceDB.GetRecord( m_pCompileContext->m_resourceID, compiledRecord ) )
                {
                    requiresCompilation = ( compiledRecord.m_advancedUpToDateHash != m_pCompileContext->m_advancedUpToDateHash );
                }
            }
        }

        // Should we proceed with the compilation?
        //-------------------------------------------------------------------------

        if ( !requiresCompilation && !m_forceCompilation )
        {
            EE_LOG_INFO( "Resource", "Resource Compiler", "Resource is up to date, nothing to do!" );
            return Resource::CompilationResult::SuccessUpToDate;
        }

        // Compile
        //-------------------------------------------------------------------------

        Resource::CompilationResult compilationResult;

        Milliseconds compileTime = 0.0f;
        {
            ScopedTimer<PlatformClock> compileTimer( compileTime );

            compilationResult = pCompiler->Compile( *m_pCompileContext );

            // Update database
            if ( compilationResult == Resource::CompilationResult::Success || compilationResult == Resource::CompilationResult::SuccessWithWarnings )
            {
                Resource::CompiledResourceRecord record;
                record.m_resourceID = m_pCompileContext->m_resourceID;
                record.m_compilerVersion = m_compileDependencyTreeRoot.m_compilerVersion;
                record.m_fileTimestamp = m_compileDependencyTreeRoot.m_timestamp;
                record.m_sourceTimestampHash = m_pCompileContext->m_sourceResourceHash;
                record.m_advancedUpToDateHash = m_pCompileContext->m_advancedUpToDateHash;
                m_compiledResourceDB.WriteRecord( record );
            }
        }

        EE_LOG_INFO( "Resource", "Resource Compiler", "Compilation took: %.2fms", compileTime.ToFloat() );
        EE_LOG_INFO( "Resource", "Resource Compiler", "Total time: %.2fms", ( upToDateCheckTime + compileTime ).ToFloat() );

        return compilationResult;
    }

    bool ResourceCompilerApplication::BuildCompileDependencyTree( ResourceID const& resourceID )
    {
        EE_ASSERT( resourceID.IsValid() );

        //-------------------------------------------------------------------------

        m_errorMessage.clear();
        m_uniqueCompileDependencies.clear();
        m_compileDependencyTreeRoot.Reset();
        return FillCompileDependencyNode( &m_compileDependencyTreeRoot, resourceID.GetResourcePath() );
    }

    bool ResourceCompilerApplication::TryReadCompileDependencies( ResourceID const& resourceID, TVector<DataPath>& outDependencies )
    {
        EE_ASSERT( resourceID.IsValid() );

        // Entity descriptors have no compile dependencies
        if ( EntityModel::IsResourceAnEntityDescriptor( resourceID.GetResourceTypeID() ) )
        {
            return true;
        }

        //-------------------------------------------------------------------------

        if ( resourceID.IsSubResourceID() )
        {
            ResourceID const parentResourceID = resourceID.GetParentResourceID();
            ResourceTypeID const parentResourceTypeID = parentResourceID.GetResourceTypeID();
            if ( !m_typeRegistry.IsRegisteredResourceType( parentResourceTypeID ) )
            {
                m_errorMessage.sprintf( "Invalid parent resource type detected for: %s", resourceID.c_str() );
                return false;
            }

            outDependencies.emplace_back( parentResourceID.GetResourcePath() );
        }
        else
        {
            FileSystem::Path const resourceFilePath = resourceID.GetFileSystemPath( m_pCompileContext->m_sourceDataDirectoryPath );

            auto pDescriptor = ResourceDescriptor::TryReadFromFile( m_typeRegistry, resourceFilePath );
            if ( pDescriptor == nullptr )
            {
                return false;
            }

            pDescriptor->GetCompileDependencies( outDependencies );

            EE::Delete( pDescriptor );
        }

        return true;
    }

    bool ResourceCompilerApplication::FillCompileDependencyNode( CompileDependencyNode* pNode, DataPath const& resourcePath )
    {
        EE_ASSERT( pNode != nullptr );
        EE_ASSERT( resourcePath.IsValid() );

        // Basic resource info
        //-------------------------------------------------------------------------

        pNode->m_ID = resourcePath;
        pNode->m_sourcePath = resourcePath.GetFileSystemPath( m_pCompileContext->m_sourceDataDirectoryPath );
        pNode->m_sourceExists = FileSystem::Exists( pNode->m_sourcePath );
        pNode->m_timestamp = pNode->m_sourceExists ? FileSystem::GetFileModifiedTime( pNode->m_sourcePath ) : 0;

        ResourceTypeID const resourceTypeID = pNode->m_ID.GetResourceTypeID();
        bool const isPotentiallyCompilableResource = pNode->m_ID.IsValid() && m_typeRegistry.IsRegisteredResourceType( resourceTypeID );
        bool skipDependencyCheck = true;

        // Handle compilable resources
        //-------------------------------------------------------------------------

        if ( isPotentiallyCompilableResource )
        {
            EE_ASSERT( pNode->m_ID.IsValid() );

            Compiler const* pCompiler = m_pCompilerRegistry->GetCompilerForResourceType( resourceTypeID );
            bool const isCompilableResource = pCompiler != nullptr;
            skipDependencyCheck = !isCompilableResource || !ShouldCheckCompileDependenciesForResourceType( pNode->m_ID );
            if ( isCompilableResource )
            {
                pNode->m_targetPath = resourcePath.GetFileSystemPath( m_pCompileContext->m_compiledResourceDirectoryPath );
                pNode->m_targetExists = FileSystem::Exists( pNode->m_targetPath );

                if ( pNode->m_targetExists && pCompiler->WillGenerateAdditionalDataFile( resourceTypeID ) )
                {
                    FileSystem::Path const additionalDataFilePath = IResource::GetAdditionalDataFilePath( pNode->m_targetPath );
                    pNode->m_targetExists = FileSystem::Exists( additionalDataFilePath );
                }

                pNode->m_compilerVersion = pCompiler->GetVersion( resourceTypeID );
                m_compiledResourceDB.GetRecord( pNode->m_ID, pNode->m_compiledRecord );

                // Some compilers dont require an input file to run - these resources should always be recompiled!
                if ( !pNode->m_sourceExists && !pCompiler->IsInputFileRequired() )
                {
                    pNode->m_forceRecompile = true;
                    skipDependencyCheck = true;
                }
            }
        }

        // Generate dependencies
        //-------------------------------------------------------------------------

        if ( !skipDependencyCheck )
        {
            TVector<DataPath> dependencies;
            if ( TryReadCompileDependencies( resourcePath, dependencies ) )
            {
                for ( auto const& dependencyResourceID : dependencies )
                {
                    // Skip resources already in the tree!
                    if ( VectorContains( m_uniqueCompileDependencies, dependencyResourceID ) )
                    {
                        continue;
                    }

                    // Check for circular references
                    //-------------------------------------------------------------------------

                    auto pNodeToCheck = pNode;
                    while ( pNodeToCheck != nullptr )
                    {
                        if ( pNodeToCheck->m_ID == dependencyResourceID )
                        {
                            m_errorMessage = "Circular dependency detected!";
                            return false;
                        }

                        pNodeToCheck = pNodeToCheck->m_pParentNode;
                    }

                    // Create dependency
                    //-------------------------------------------------------------------------

                    auto pChildDependencyNode = pNode->m_dependencies.emplace_back( EE::New<CompileDependencyNode>() );
                    pChildDependencyNode->m_pParentNode = pNode;
                    if ( !FillCompileDependencyNode( pChildDependencyNode, dependencyResourceID ) )
                    {
                        return false;
                    }

                    m_uniqueCompileDependencies.emplace_back( dependencyResourceID );
                }
            }
            else
            {
                pNode->m_errorOccurredReadingDependencies = true;
                return false;
            }
        }

        // Generate combined hash
        //-------------------------------------------------------------------------

        pNode->m_combinedHash = pNode->m_timestamp;
        for ( auto const pDep : pNode->m_dependencies )
        {
            pNode->m_combinedHash += pDep->m_combinedHash;
        }

        return true;
    }
}

//-------------------------------------------------------------------------
// Application Entry Point
//-------------------------------------------------------------------------

using namespace EE;

//-------------------------------------------------------------------------

int main( int argc, char* argv[] )
{
    ApplicationGlobalState State;

    // Print log delimiter
    //-------------------------------------------------------------------------

    std::cout << EE::Resource::CompilationLog::s_delimiter;

    // Read CMD line arguments and process request
    //-------------------------------------------------------------------------

    CommandLineArgumentParser argParser( argc, argv );

    if ( !argParser.IsValid() )
    {
        for ( int i = 0; i < argc; i++ )
        {
            std::cout << argv[i] << std::endl;
        }

        EE_LOG_ERROR( "Resource", "Resource Compiler", "Invalid command line arguments" );
        return -1;
    }

    // Debug Hook
    //-------------------------------------------------------------------------

    if ( argParser.m_triggerDebugBreak )
    {
        EE_HALT();
    }

    // Compile Resource
    //-------------------------------------------------------------------------

    int32_t result = -1;
    Resource::ResourceCompilerApplication application;
    FileSystem::Path const iniFilePath = FileSystem::GetCurrentProcessPath().Append( "Esoterica.ini" );
    if ( application.Initialize( argParser, iniFilePath ) )
    {
        result = (int32_t) application.Run();
    }
    application.Shutdown();

    return result;
}